{"version":3,"file":"single-spa-angular.min.js","sources":["../lib/fesm2022/single-spa-angular.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { Injectable, Inject } from '@angular/core';\nimport { getContainerElementAndSetTemplate } from 'single-spa-angular/internals';\nimport { BrowserPlatformLocation, DOCUMENT, PlatformLocation } from '@angular/common';\n\nfunction enableProdMode() {\n    try {\n        // The `enableProdMode` will throw an error if it's called multiple times,\n        // but it may be called multiple times when dependencies are shared.\n        i0.enableProdMode();\n    }\n    catch {\n        // Nothing to do here.\n    }\n}\n\nclass SingleSpaPlatformLocation extends BrowserPlatformLocation {\n    constructor() {\n        super(...arguments);\n        // This is a simple marker that helps us to ignore PopStateEvents\n        // that was not dispatched by the browser.\n        this.skipNextPopState = false;\n        this.source = 'Window.addEventListener:popstate';\n    }\n    pushState(state, title, url) {\n        this.skipNextPopState = true;\n        super.pushState(state, title, url);\n    }\n    replaceState(state, title, url) {\n        this.skipNextPopState = true;\n        super.replaceState(state, title, url);\n    }\n    onPopState(fn) {\n        // `Zone.current` will reference the zone that serves as an execution context\n        // to some specific application, especially when `onPopState` is called.\n        const zone = Zone.current;\n        // Wrap any event listener into zone that is specific to some application.\n        // The main issue is `back/forward` buttons of browsers, because they invoke\n        // `history.back|forward` which dispatch `popstate` event. Since `single-spa`\n        // overrides `history.replaceState` Angular's zone cannot intercept this event.\n        // Only the root zone is able to intercept all events.\n        // See https://github.com/single-spa/single-spa-angular/issues/94 for more details\n        fn = zone.wrap(fn, this.source);\n        const onPopStateListener = (event) => {\n            // The `LocationChangeEvent` doesn't have the `singleSpa` property, since it's added\n            // by `single-spa` starting from `5.4` version. We need this check because we want\n            // to skip \"unnatural\" PopStateEvents, the one caused by `single-spa`.\n            const popStateEventWasDispatchedBySingleSpa = !!event\n                .singleSpa;\n            if (this.skipNextPopState && popStateEventWasDispatchedBySingleSpa) {\n                this.skipNextPopState = false;\n            }\n            else {\n                fn(event);\n            }\n        };\n        return super.onPopState(onPopStateListener);\n    }\n    /** @nocollapse */ static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"19.2.9\", ngImport: i0, type: SingleSpaPlatformLocation, deps: null, target: i0.ɵɵFactoryTarget.Injectable }); }\n    /** @nocollapse */ static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"19.2.9\", ngImport: i0, type: SingleSpaPlatformLocation }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"19.2.9\", ngImport: i0, type: SingleSpaPlatformLocation, decorators: [{\n            type: Injectable\n        }] });\n/**\n * The `PlatformLocation` class is an \"injectee\" of the `PathLocationStrategy`,\n * which creates `Subject` internally for listening on `popstate` events. We want\n * to provide this class in the most top injector that's used during bootstrapping.\n */\nfunction getSingleSpaExtraProviders() {\n    return [\n        {\n            provide: SingleSpaPlatformLocation,\n            deps: [[new Inject(DOCUMENT)]],\n        },\n        {\n            provide: PlatformLocation,\n            useExisting: SingleSpaPlatformLocation,\n        },\n    ];\n}\n\nconst defaultOptions = {\n    // Required options that will be set by the library consumer.\n    NgZone: null,\n    bootstrapFunction: null,\n    template: null,\n    // Optional options\n    Router: undefined,\n    domElementGetter: undefined, // only optional if you provide a domElementGetter as a custom prop\n    updateFunction: () => Promise.resolve(),\n    bootstrappedNgModuleRefOrAppRef: null,\n};\nconst NG_DEV_MODE = typeof ngDevMode === 'undefined' || ngDevMode;\nfunction singleSpaAngular(userOptions) {\n    if (NG_DEV_MODE && typeof userOptions !== 'object') {\n        throw Error('single-spa-angular requires a configuration object');\n    }\n    const options = {\n        ...defaultOptions,\n        ...userOptions,\n    };\n    if (NG_DEV_MODE && typeof options.bootstrapFunction !== 'function') {\n        throw Error('single-spa-angular must be passed an options.bootstrapFunction');\n    }\n    if (NG_DEV_MODE && typeof options.template !== 'string') {\n        throw Error('single-spa-angular must be passed options.template string');\n    }\n    if (NG_DEV_MODE && !options.NgZone) {\n        throw Error(`single-spa-angular must be passed the NgZone option`);\n    }\n    if (NG_DEV_MODE && options.Router && !options.NavigationStart) {\n        // We call `console.warn` except of throwing `new Error()` since this will not\n        // be a breaking change.\n        console.warn(`single-spa-angular must be passed the NavigationStart option`);\n    }\n    return {\n        bootstrap: bootstrap.bind(null, options),\n        mount: mount.bind(null, options),\n        unmount: unmount.bind(null, options),\n        update: options.updateFunction,\n    };\n}\nasync function bootstrap(options) {\n    // Angular provides an opportunity to develop `zone-less` application, where developers\n    // have to trigger change detection manually.\n    // See https://angular.io/guide/zone#noopzone\n    if (options.NgZone === 'noop') {\n        return;\n    }\n    // Note that we have to make it a noop function because it's a static property and not\n    // an instance property. We're unable to configure it for multiple apps when dependencies\n    // are shared and reference the same `NgZone` class. We can't determine where this function\n    // is being executed or under which application, making it difficult to assert whether this\n    // app is running under its zone.\n    options.NgZone.assertInAngularZone = () => { };\n    options.NgZone.assertNotInAngularZone = () => { };\n    options.routingEventListener = () => {\n        options.bootstrappedNgZone.run(() => {\n            // See https://github.com/single-spa/single-spa-angular/issues/86\n            // Zone is unaware of the single-spa navigation change and so Angular change detection doesn't work\n            // unless we tell Zone that something happened\n        });\n    };\n}\nasync function mount(options, props) {\n    getContainerElementAndSetTemplate(options, props);\n    const bootstrapPromise = options.bootstrapFunction(props);\n    if (NG_DEV_MODE && !(bootstrapPromise instanceof Promise)) {\n        throw Error(`single-spa-angular: the options.bootstrapFunction must return a promise, but instead returned a '${typeof bootstrapPromise}' that is not a Promise`);\n    }\n    const ngModuleRefOrAppRef = await bootstrapPromise;\n    if (NG_DEV_MODE) {\n        if (!ngModuleRefOrAppRef || typeof ngModuleRefOrAppRef.destroy !== 'function') {\n            throw Error(`single-spa-angular: the options.bootstrapFunction returned a promise that did not resolve with a valid Angular module or ApplicationRef. Did you call platformBrowserDynamic().bootstrapModule() correctly?`);\n        }\n    }\n    const singleSpaPlatformLocation = ngModuleRefOrAppRef.injector.get(SingleSpaPlatformLocation, null);\n    const ngZoneEnabled = options.NgZone !== 'noop';\n    // The user has to provide `BrowserPlatformLocation` only if his application uses routing.\n    // So if he provided `Router` but didn't provide `BrowserPlatformLocation` then we have to inform him.\n    // Also `getSingleSpaExtraProviders()` function should be called only if the user doesn't use\n    // `zone-less` change detection, if `NgZone` is `noop` then we can skip it.\n    if (NG_DEV_MODE && ngZoneEnabled && options.Router && singleSpaPlatformLocation === null) {\n        throw new Error(`\n      single-spa-angular: could not retrieve extra providers from the platform injector. Did you call platformBrowserDynamic(getSingleSpaExtraProviders()).bootstrapModule()?\n    `);\n    }\n    const bootstrappedOptions = options;\n    if (ngZoneEnabled) {\n        const ngZone = ngModuleRefOrAppRef.injector.get(options.NgZone);\n        // `NgZone` can be enabled but routing may not be used thus `getSingleSpaExtraProviders()`\n        // function was not called.\n        if (singleSpaPlatformLocation !== null) {\n            skipLocationChangeOnNonImperativeRoutingTriggers(ngModuleRefOrAppRef, options);\n        }\n        bootstrappedOptions.bootstrappedNgZone = ngZone;\n        window.addEventListener('single-spa:routing-event', bootstrappedOptions.routingEventListener);\n    }\n    bootstrappedOptions.bootstrappedNgModuleRefOrAppRef = ngModuleRefOrAppRef;\n    return ngModuleRefOrAppRef;\n}\nfunction unmount(options) {\n    return Promise.resolve().then(() => {\n        if (options.routingEventListener) {\n            window.removeEventListener('single-spa:routing-event', options.routingEventListener);\n        }\n        options.bootstrappedNgModuleRefOrAppRef.destroy();\n        options.bootstrappedNgModuleRefOrAppRef = null;\n    });\n}\nfunction skipLocationChangeOnNonImperativeRoutingTriggers(ngModuleRefOrAppRef, options) {\n    if (!options.NavigationStart) {\n        // As discussed we don't do anything right now if the developer doesn't provide\n        // `options.NavigationStart` since this might be a breaking change.\n        return;\n    }\n    const router = ngModuleRefOrAppRef.injector.get(options.Router);\n    const subscription = router.events.subscribe((event) => {\n        if (event instanceof options.NavigationStart) {\n            const currentNavigation = router.getCurrentNavigation();\n            // This listener will be set up for each Angular application\n            // that has routing capabilities.\n            // We set `skipLocationChange` for each non-imperative navigation,\n            // Angular router checks under the hood if it has to change\n            // the browser URL or not.\n            // If `skipLocationChange` is truthy then Angular router will not call\n            // `setBrowserUrl()` which calls `history.replaceState()` and dispatches `popstate` event.\n            if (currentNavigation.trigger !== 'imperative') {\n                currentNavigation.extras.skipLocationChange = true;\n                currentNavigation.extras.replaceUrl = false;\n            }\n        }\n    });\n    ngModuleRefOrAppRef.onDestroy(() => subscription.unsubscribe());\n}\n\n/**\n * The public api for consumers of single-spa-angular\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { enableProdMode, getSingleSpaExtraProviders, singleSpaAngular };\n//# sourceMappingURL=single-spa-angular.mjs.map\n"],"names":["enableProdMode","i0"],"mappings":"sQAEgBA,SAAAA,IACd,IAGEC,EAAKD,gBACN,CAAC,OAGJ"}